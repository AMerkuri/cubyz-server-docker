name: Poll Upstream Cubyz Tags

on:
  schedule:
    - cron: '0 * * * *' # hourly
  workflow_dispatch:

permissions:
  contents: write
  packages: read
  actions: write

concurrency:
  group: poll-upstream-tags
  cancel-in-progress: true

jobs:
  poll-and-dispatch:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: read
      actions: write
    env:
      UPSTREAM_OWNER: PixelGuys
      UPSTREAM_REPO: Cubyz
      TARGET_REPOSITORY: ${{ github.repository }}
      MAX_MISSING: 5
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check master branch for changes (dev build)
        id: check_master
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          
          # Get latest commit SHA from upstream master
          UPSTREAM_SHA=$(curl -sS "https://api.github.com/repos/${UPSTREAM_OWNER}/${UPSTREAM_REPO}/commits/master" | jq -r '.sha')
          echo "Upstream master SHA: $UPSTREAM_SHA"
          
          # Get the SHA we last built (stored in a file or check the dev image label)
          # We'll use a simple approach: check if dev image exists and compare
          LAST_SHA=""
          if gh api -H "Accept: application/vnd.github+json" \
            "/users/${{ github.repository_owner }}/packages/container/cubyz-server-docker/versions?per_page=100" \
            > pkg_versions_dev.json 2>/dev/null; then
            # Check if dev tag exists
            DEV_EXISTS=$(jq -r '.[] | select(.metadata.container.tags[]? == "dev") | .id' pkg_versions_dev.json | head -n1 || true)
            if [ -n "$DEV_EXISTS" ]; then
              echo "Dev image exists"
              # Try to get the last built SHA from our tracking file
              if [ -f .last-dev-sha ]; then
                LAST_SHA=$(cat .last-dev-sha)
              fi
            fi
          fi
          
          echo "Last built SHA: ${LAST_SHA:-none}"
          
          if [ "$UPSTREAM_SHA" != "$LAST_SHA" ]; then
            echo "needs_dev_build=true" >> "$GITHUB_OUTPUT"
            echo "upstream_sha=$UPSTREAM_SHA" >> "$GITHUB_OUTPUT"
            echo "Master branch has new commits, dev build needed"
          else
            echo "needs_dev_build=false" >> "$GITHUB_OUTPUT"
            echo "No new commits on master, skipping dev build"
          fi

      - name: Fetch latest upstream tags
        run: |
          set -euo pipefail
          curl -sS "https://api.github.com/repos/${UPSTREAM_OWNER}/${UPSTREAM_REPO}/tags?per_page=100" > upstream_tags.json
          # Build pairs of (original_tag normalized_tag) and a normalized-only list
          jq -r '.[].name' upstream_tags.json | grep -E '^(v)?[0-9]+\.[0-9]+\.[0-9]+' | while read -r t; do
            n="${t#v}"
            echo "$t $n"
          done | sort -k2,2 -rV -u > upstream_pairs.txt || true
          awk '{print $2}' upstream_pairs.txt | sort -rV -u > upstream_norm.txt || true
          echo "Upstream tags (original -> normalized):"
          cat upstream_pairs.txt || true

      - name: Get existing image tags from GHCR
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          # Query GitHub Packages API for container versions/tags. If package doesn't exist yet, return empty list.
          if ! gh api -H "Accept: application/vnd.github+json" \
            "/users/${{ github.repository_owner }}/packages/container/cubyz-server-docker/versions?per_page=100" \
            > pkg_versions.json 2>/dev/null; then
            echo "[]" > pkg_versions.json
          fi
          jq -r '.[] | .metadata.container.tags[]?' pkg_versions.json | sort -rV -u > existing_tags.txt || true
          echo "Existing GHCR tags:"
          cat existing_tags.txt || true

      - name: Compute missing tags
        id: diff
        run: |
          set -euo pipefail
          touch upstream_norm.txt existing_tags.txt upstream_pairs.txt
          # Normalized tags present upstream but not yet in GHCR
          comm -23 <(sort -u upstream_norm.txt) <(sort -u existing_tags.txt) > missing_norm.txt || true
          COUNT=$(wc -l < missing_norm.txt | tr -d ' ')
          echo "Missing normalized tags count: $COUNT"
          echo "count=$COUNT" >> "$GITHUB_OUTPUT"
          # Join back to original tags, keep newest-first (version sort descending by normalized field)
          # Result format: "ORIG NORM"
          if [ -s missing_norm.txt ]; then
            awk 'NR==FNR{miss[$0]=1;next} ($2 in miss){print $0}' missing_norm.txt upstream_pairs.txt | sort -k2,2 -rV > missing_pairs.txt
          else
            : > missing_pairs.txt
          fi
          echo "Missing tags to dispatch (orig -> norm, newest first):"
          cat missing_pairs.txt || true
          # Limit to newest MAX_MISSING tags to avoid backlog stampede
          head -n "$MAX_MISSING" missing_pairs.txt > missing_limited_pairs.txt || true
          LN=$(wc -l < missing_limited_pairs.txt | tr -d ' ')
          echo "limited_count=$LN" >> "$GITHUB_OUTPUT"

      - name: Dispatch dev build for master branch
        if: ${{ steps.check_master.outputs.needs_dev_build == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          echo "Dispatching dev build for master branch to ${TARGET_REPOSITORY}"
          if curl -sSf -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            "https://api.github.com/repos/${TARGET_REPOSITORY}/dispatches" \
            -d '{"event_type":"cubyz-release","client_payload":{"tag":"master","is_dev":true}}'
          then
            # Store the SHA we're building
            echo "${{ steps.check_master.outputs.upstream_sha }}" > .last-dev-sha
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add .last-dev-sha
            git commit -m "chore(ci): update last dev build SHA" || true
            git push || true
          else
            echo "Failed to dispatch dev build" >&2
          fi

      - name: Dispatch builds for missing tags
        if: ${{ steps.diff.outputs.limited_count != '0' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          # Dispatch newest-first to get the latest release built earlier
          while read -r ORIG NORM; do
            [ -z "$ORIG" ] && continue
            echo "Dispatching build for $ORIG (normalized: $NORM) to ${TARGET_REPOSITORY}"
            if ! curl -sSf -X POST \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              "https://api.github.com/repos/${TARGET_REPOSITORY}/dispatches" \
              -d "{\"event_type\":\"cubyz-release\",\"client_payload\":{\"tag\":\"${ORIG}\",\"is_dev\":false}}"
            then
              echo "Failed to dispatch for $ORIG" >&2
            fi
          done < missing_limited_pairs.txt
